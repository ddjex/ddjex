(function(global) { 'use strict'; class StateManager { constructor() { this.values = new Map(); this.subscribers = new Map(); this.computed = new Map(); this.computedDeps = new Map(); } define(id, initial) { this.values.set(id, initial); this.subscribers.set(id, new Set()); } defineComputed(id, deps, fn) { this.computedDeps.set(id, deps); this.computed.set(id, fn); this.subscribers.set(id, new Set()); } get(id) { if (this.computed.has(id)) { return this.computed.get(id)(); } return this.values.get(id); } set(id, value) { if (this.values.get(id) === value) return; this.values.set(id, value); this.notify(id); } notify(id) { this.subscribers.get(id)?.forEach(fn => fn()); const notified = new Set([id]); const queue = [id]; while (queue.length > 0) { const current = queue.shift(); for (const [compId, deps] of this.computedDeps) { if (deps.includes(current) && !notified.has(compId)) { notified.add(compId); queue.push(compId); this.subscribers.get(compId)?.forEach(fn => fn()); } } } } subscribe(id, fn) { this.subscribers.get(id)?.add(fn); return () => this.subscribers.get(id)?.delete(fn); } mutate(id, op, value) { const current = this.get(id); let next; switch (op) { case 'set': next = value; break; case 'add': next = current + value; break; case 'subtract': next = current - value; break; case 'multiply': next = current * value; break; case 'divide': next = current / value; break; case 'toggle': next = !current; break; case 'push': next = [...current, value]; break; case 'pop': next = current.slice(0, -1); break; case 'shift': next = current.slice(1); break; case 'unshift': next = [value, ...current]; break; case 'merge': next = { ...current, ...value }; break; default: next = value; } this.set(id, next); } snapshot() { const result = {}; for (const [id, val] of this.values) { result[id] = val; } return result; } } const ops = { add: (a, b) => a + b, subtract: (a, b) => a - b, multiply: (a, b) => a * b, divide: (a, b) => a / b, modulo: (a, b) => a % b, min: (...a) => Math.min(...a), max: (...a) => Math.max(...a), abs: a => Math.abs(a), round: a => Math.round(a), floor: a => Math.floor(a), ceil: a => Math.ceil(a), eq: (a, b) => a === b, neq: (a, b) => a !== b, gt: (a, b) => a > b, gte: (a, b) => a >= b, lt: (a, b) => a < b, lte: (a, b) => a <= b, and: (...a) => a.every(Boolean), or: (...a) => a.some(Boolean), not: a => !a, length: a => a?.length ?? 0, first: a => a?.[0], last: a => a?.[a.length - 1], at: (a, i) => a?.[i], slice: (a, s, e) => a?.slice(s, e), concat: (...a) => [].concat(...a), includes: (a, v) => a?.includes(v), indexOf: (a, v) => a?.indexOf(v), join: (a, s) => a?.join(s), reverse: a => [...a].reverse(), unique: a => [...new Set(a)], get: (o, k) => o?.[k], set: (o, k, v) => ({ ...o, [k]: v }), keys: o => Object.keys(o ?? {}), values: o => Object.values(o ?? {}), merge: (...o) => Object.assign({}, ...o), has: (o, k) => k in (o ?? {}), split: (s, d) => s?.split(d), trim: s => s?.trim(), toUpperCase: s => s?.toUpperCase(), toLowerCase: s => s?.toLowerCase(), startsWith: (s, p) => s?.startsWith(p), endsWith: (s, p) => s?.endsWith(p), substring: (s, a, b) => s?.substring(a, b), replace: (s, f, t) => s?.replace(f, t), replaceAll: (s, f, t) => s?.replaceAll(f, t), toString: v => String(v), toNumber: v => Number(v), parseInt: v => parseInt(v, 10), parseFloat: v => parseFloat(v), isNull: v => v === null, isUndefined: v => v === undefined, isDefined: v => v != null, typeof: v => typeof v, if: (c, t, e) => c ? t : e, coalesce: (...v) => v.find(x => x != null), now: () => Date.now(), uuid: () => crypto.randomUUID?.() ?? `${Date.now()}-${Math.random().toString(36).slice(2)}`, log: (...a) => console.log(...a), eventValue: null, eventKey: null, }; function resolve(expr, ctx) { if (expr === null || expr === undefined) return expr; if (typeof expr !== 'object') return expr; if (Array.isArray(expr)) return expr.map(e => resolve(e, ctx)); if ('ref' in expr) { const path = expr.ref.split('.'); let val = ctx.scope[path[0]] ?? ctx.state.get(path[0]); for (let i = 1; i < path.length; i++) val = val?.[path[i]]; return val; } if ('param' in expr) { return ctx.params?.[expr.param]; } if ('text' in expr) return expr.text; if ('bind' in expr) { const path = expr.bind.split('.'); let val = ctx.scope[path[0]] ?? ctx.state.get(path[0]); for (let i = 1; i < path.length; i++) val = val?.[path[i]]; return val; } if ('op' in expr) { const opName = expr.op; const args = expr.args || []; if (['map', 'filter', 'find', 'some', 'every', 'findIndex'].includes(opName)) { const arr = resolve(args[0], ctx); if (!Array.isArray(arr)) return opName === 'find' ? undefined : []; const predicate = args[1]; const evalItem = (item, index) => { const itemCtx = { ...ctx, scope: { ...ctx.scope, item, index }, params: { ...ctx.params, item, index } }; return resolve(predicate, itemCtx); }; switch (opName) { case 'map': return arr.map(evalItem); case 'filter': return arr.filter(evalItem); case 'find': return arr.find(evalItem); case 'findIndex': return arr.findIndex(evalItem); case 'some': return arr.some(evalItem); case 'every': return arr.every(evalItem); } } const fn = ops[opName]; if (!fn) throw new Error(`Unknown op: ${opName}`); const resolvedArgs = args.map(a => resolve(a, ctx)); return fn(...resolvedArgs); } const result = {}; for (const [k, v] of Object.entries(expr)) { result[k] = resolve(v, ctx); } return result; } function renderNode(node, ctx, runtime) { if ('text' in node) { return document.createTextNode(node.text); } if ('bind' in node) { const textNode = document.createTextNode(''); const path = node.bind.split('.'); const update = () => { let val = ctx.scope[path[0]] ?? ctx.state.get(path[0]); for (let i = 1; i < path.length; i++) val = val?.[path[i]]; textNode.textContent = val ?? ''; }; update(); if (!(path[0] in ctx.scope)) { ctx.state.subscribe(path[0], update); for (const [compId, deps] of ctx.state.computedDeps) { if (path[0] === compId || deps.includes(path[0])) { ctx.state.subscribe(compId, update); } } } return textNode; } if ('if' in node && 'then' in node) { const container = document.createElement('span'); let current = null; const update = () => { const cond = resolve(node.if, ctx); const template = cond ? node.then : node.else; if (current) { container.removeChild(current); current = null; } if (template) { current = renderNode(template, ctx, runtime); container.appendChild(current); } }; update(); const refs = extractRefs(node.if); refs.forEach(ref => ctx.state.subscribe(ref, update)); return container; } if ('type' in node) { const el = document.createElement(node.type); if (node.props) { for (const [key, val] of Object.entries(node.props)) { const resolved = resolve(val, ctx); if (key === 'className' || key === 'class') { el.className = resolved ?? ''; } else if (key === 'style' && typeof resolved === 'object') { Object.assign(el.style, resolved); } else if (key === 'checked' || key === 'disabled' || key === 'selected') { el[key] = !!resolved; } else if (key === 'value') { el.value = resolved ?? ''; } else if (resolved != null) { el.setAttribute(key, resolved); } } } if (node.events) { for (const [event, handler] of Object.entries(node.events)) { el.addEventListener(event, (e) => { if (event === 'keydown' && e.key !== 'Enter') return; const args = (handler.args || []).map(arg => { if (arg?.op === 'eventValue') return e.target.value; if (arg?.op === 'eventKey') return e.key; return resolve(arg, ctx); }); runtime.dispatch(handler.action, ...args); }); } } if (node.each) { const { items: itemsRef, as: itemName, index: indexName } = node.each; let currentEls = []; const updateLoop = () => { const arr = ctx.state.get(itemsRef) || []; currentEls.forEach(child => el.removeChild(child)); currentEls = []; arr.forEach((item, index) => { const itemScope = { ...ctx.scope, [itemName]: item }; if (indexName) itemScope[indexName] = index; const itemCtx = { ...ctx, scope: itemScope }; (node.children || []).forEach(child => { const childEl = renderNode(child, itemCtx, runtime); el.appendChild(childEl); currentEls.push(childEl); }); }); }; updateLoop(); ctx.state.subscribe(itemsRef, updateLoop); return el; } if (node.children) { node.children.forEach(child => { el.appendChild(renderNode(child, ctx, runtime)); }); } return el; } return document.createTextNode(''); } function extractRefs(expr) { const refs = []; const extract = (e) => { if (!e || typeof e !== 'object') return; if ('ref' in e) refs.push(e.ref.split('.')[0]); if ('op' in e && e.args) e.args.forEach(extract); if (Array.isArray(e)) e.forEach(extract); }; extract(expr); return refs; } class Runtime { constructor(program) { this.program = program; this.state = new StateManager(); this.actions = new Map(); } init() { if (this.program.state) { for (const [id, def] of Object.entries(this.program.state)) { this.state.define(id, def.initial); } } if (this.program.computed) { for (const [id, def] of Object.entries(this.program.computed)) { const fn = () => resolve(def.fn, { state: this.state, scope: {}, params: {} }); this.state.defineComputed(id, def.deps, fn); } } if (this.program.actions) { for (const [id, def] of Object.entries(this.program.actions)) { this.actions.set(id, def); } } if (this.program.effects) { for (const effect of this.program.effects) { const run = () => resolve(effect.do, { state: this.state, scope: {}, params: {} }); run(); effect.watch.forEach(w => this.state.subscribe(w, run)); } } return this; } dispatch(actionId, ...args) { const action = this.actions.get(actionId); if (!action) { console.error(`Unknown action: ${actionId}`); return; } const params = {}; (action.params || []).forEach((name, i) => params[name] = args[i]); for (const mut of action.mutations) { let value = mut.value !== undefined ? resolve(mut.value, { state: this.state, scope: {}, params }) : undefined; if (mut.op === 'map' || mut.op === 'filter') { const arr = this.state.get(mut.target); const result = arr[mut.op]((item, index) => { return resolve(mut.value, { state: this.state, scope: { item, index }, params: { ...params, item, index } }); }); this.state.set(mut.target, result); } else { this.state.mutate(mut.target, mut.op, value); } } } mount(container) { const el = typeof container === 'string' ? document.querySelector(container) : container; if (!el) throw new Error(`Container not found: ${container}`); if (this.program.root) { const ctx = { state: this.state, scope: {}, params: {} }; el.innerHTML = ''; el.appendChild(renderNode(this.program.root, ctx, this)); } return this; } getState() { return this.state.snapshot(); } } function run(program, options = {}) { const runtime = new Runtime(program); runtime.init(); runtime.mount(options.container || '#app'); return runtime; } function createApp(program) { return new Runtime(program).init(); } global.DDJEX = { run, createApp, Runtime, StateManager, ops, resolve, version: '0.1.0' }; })(typeof window !== 'undefined' ? window : global);